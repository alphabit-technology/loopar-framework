import { GlobalEnvironment } from '../global/element-definition.js';
import path from "pathe";
import dayjs from "dayjs";
import crypto from "crypto-js";
import { getHttpError } from '../global/http-errors.js';
import * as lucideIcons from 'lucide-react'
import { fileManage } from "../file-manage.js";
import { elementsDict } from "../global/element-definition.js";

export class Builder {
  async buildRefs() {
    let types = {};
    const docs = this.getEntities();

    const getEntityFields = (fields) => {
      const getFields = fields => fields.reduce((acc, field) => acc.concat(field, ...getFields(field.elements || [])), []);

      return getFields(fields).filter(field => {
        const def = elementsDict[field.element]?.def || {};
        return def.isWritable && !!field.data.name// && !field.element.includes(FORM_TABLE);
      }).map(field => field.data.name)
    }

    const refs = Object.values(docs).reduce((acc, doc) => {
      if (doc.__document_status__ == "Deleted") return acc;
      
      const isBuilder = (doc.build || ['Builder', 'Entity'].includes(doc.name)) ? 1 : 0;
      const isChild = doc.is_child ? 1 : 0;
      const isSingle = this.entityIsSingle(doc);
      const fields = typeof doc.doc_structure == "object" ? doc.doc_structure : JSON.parse(doc.doc_structure || "[]");

      if (isBuilder) {
        types[doc.name] = {
          __ROOT__: doc.entityRoot,
          __NAME__: doc.name,
          __ENTITY__: doc.__ENTITY__ || "Entity",
          __BUILD__: doc.build || doc.name,
          __APP__: doc.__APP__,
          __ID__: doc.id,
          __TYPE__: doc.type,
          __MODULE__: doc.__MODULE__,
          __FIELDS__: getEntityFields(fields)
        }
      }

      acc[doc.name] = {
        __NAME__: doc.name,
        __APP__: doc.__APP__,
        __ENTITY__: doc.__ENTITY__ || "Entity",
        __ROOT__: doc.entityRoot,
        is_single: isSingle,
        is_builder: isBuilder,
        is_child: isChild,
        __MODULE__: doc.__MODULE__,
        __TYPE__: doc.type,
        __FIELDS__: getEntityFields(fields)
      }

      return acc;
    }, {});

    await fileManage.setConfigFile('refs', {
      types,
      refs
    });

    this.__REFS__ = refs;
    this.__TYPES__ = types;
    this.__INSTALLED_APPS__ = fileManage.getConfigFile('installed-apps');
  }

  makePath(...args) {
    let pathArray = args;

    if (!args[0].startsWith("./")) {
      pathArray = ["/", ...args];
    }

    const joinedPath = path.join(...pathArray);

    return this.utils.decamelize(joinedPath, { separator: '-' });
  }

  async buildIcons() {
    if(!this.__installed__) return;
    const refs = this.getRefs();

    
    const evalFields = (fields) => {
      return fields.reduce((acc, field) => {
        if (field.element == ICON_INPUT) {
          acc.push(field.data.name);
        }

        if (field.elements) {
          acc.push(...evalFields(field.elements));
        }

        return acc;
      }, []);
    }

    const refIcons = {};
    Object.values(refs).forEach(ref => {
      if (!ref.is_single){
        const docJson = fileManage.getConfigFile(ref.__NAME__.replaceAll(" ", "-").toLowerCase(), ref.__ROOT__);
        
        if (docJson) {
          const fields = evalFields(JSON.parse(docJson.doc_structure));
          fields.length && (refIcons[ref.__NAME__] = {fields});
        }
      }
    });

    let JSXImports = "";
    const iconImports = new Set();
    for (const [entity, ent] of Object.entries(refIcons)) {
      for (const res of await this.db.getAll(entity, ent.fields)) {
        for(const field of ent.fields) {
          const icon = (res[field] || "").replaceAll(/[- ]/g, '');
          lucideIcons[icon] && iconImports.add(res[field].replaceAll(/[- ]/g, ''));
        }
      }
    }

    JSXImports += `//this file is autogenerated\n export {${[...iconImports].join(',')}} from "lucide-react";`;

    await fileManage.makeFile('app/auto', 'iconImport', JSXImports, 'jsx', true);
  }

  async build() {
    console.log('......Building Loopar.......');

    await this.makeDefaultFolders();
    if (this.installingApp) return;

    await this.buildRefs();
   
    const writeFile = async (data) => {
      await fileManage.setConfigFile('loopar.config', data);

      await this.loadConfig(data);
    }

    const writeModules = async (data) => {
      this.db.pagination = null;
      const groupList = await this.db.getList('Module Group', ['name', 'description'], {in_sidebar: 1 });

      for (const g of groupList) {
        const modulesGroup = { name: g.name, description: g.description, modules: [] };

        const moduleList = await this.db.getList(
          'Module',
          ['name', 'icon', 'description', 'module_group'],
          {module_group: g.name, in_sidebar: 1}
        );

        for (const m of moduleList) {
          const module = { link: m.name, icon: m.icon, description: m.description, routes: [] };

          const routeList = await this.db.getList("Entity", ['name', 'is_single'], {module: m.name});

          module.routes = routeList.map(route => {
            return { link: route.is_single ? 'update' : route.name, description: route.name }
          });

          modulesGroup.modules.push(module);
        }

        data.modulesGroup.push(modulesGroup);
      }

      data.initializedModules = true;
      this.modulesGroup = data.modulesGroup;

      await writeFile(data);
    }

    const data = {
      DBInitialized: this.DBInitialized,
      modulesGroup: []
    };

    this.DBServerInitialized = await this.db.testServer();
    this.DBInitialized = (this.DBServerInitialized && await this.db.testDatabase());
    this.__installed__ = (this.DBInitialized && await this.db.testFramework("loopar"));

    data.DBInitialized = this.DBInitialized;
    data.DBServerInitialized = this.DBServerInitialized;
    data.__installed__ = this.__installed__;

    if (data.__installed__) {
      const activeWebApp = await this.db.getDoc('System Settings');
      const webApp = await this.db.getParseDoc('App', activeWebApp.active_web_app);

      data.webApp = {
        ...(webApp || {}),
        menu_items: webApp ? await this.db.getAll("Menu Item", ["*"], { parent_id: webApp.id }) : [],
        menu_actions: webApp ? await this.db.getAll("Menu Action", ["*"], { parent_id: webApp.id }) : []
      }

      await writeModules(data);
    } else {
      await writeFile(data);
    }
  }

  async rebuildVite() {
    console.log('*********Restarting Vite*********');
    await this.server.vite.restart();
    console.log('*********Reloading Browser*********');
    await this.server.vite.ws.send({ type: 'full-reload' });
  }

  async loadConfig(data = null) {
    if (data) {
      Object.assign(this, data);
    } else {
      await this.loadConfig(fileManage.getConfigFile('loopar.config', null, {}));
    }
  }

  async writeDefaultSSettings() {
    await fileManage.makeFolder('', "config");

    if (!fileManage.existFileSync(path.join('config', 'db.config.json'))) {
      await fileManage.setConfigFile('db.config', {});
    }

    if (!fileManage.existFileSync(path.join('config', 'loopar.config.json'))) {
      await fileManage.setConfigFile('loopar.config', {});
    }

    if (!fileManage.existFileSync(path.join('config', 'server.config.json'))) {
      await fileManage.setConfigFile('server.config', {
        "port": process.env.PORT || 3000,
        "session": {
          "secret": this.id,
          "saveUninitialized": false,
          "cookie": { "maxAge": 86400000 },
          "resave": false
        }
      });
    }
  }

  async buildGlobalEnvironment() {
    GlobalEnvironment();
    
    const handleFatalError = async (err, source) => {
      console.error(`${source}:`, err);
      this.installingApp = null;
      
      await this.db.safeRollback();
      
      try {
        this.server?.renderError({ 
          error: getHttpError(err), 
          redirect: err?.redirect 
        });
      } catch (renderError) {
        console.error('Failed to render error:', renderError.message);
      }
    };

    process.on('uncaughtException', (err) => handleFatalError(err, 'uncaughtException'));
    process.on('unhandledRejection', (err) => handleFatalError(err, 'unhandledRejection'));

    global.Crypto = crypto;
    global.AJAX = 'POST';
    global.env = {};
    global.dayjs = dayjs;

    await this.writeDefaultSSettings();

    env.dbConfig = fileManage.getConfigFile('db.config');
    env.looparConfig = fileManage.getConfigFile('loopar.config', null, {});
    env.serverConfig = fileManage.getConfigFile('server.config');
  }

  async makeDefaultFolders() {
    await fileManage.makeFolder("apps");
    await fileManage.makeFolder("app", "auto");
    await fileManage.makeFolder('uploads', "public", "thumbnails");
    await fileManage.makeFolder('uploads', "private", "thumbnails");
  }
}